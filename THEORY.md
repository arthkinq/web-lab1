### **Вопрос: Протокол HTTP. Структура запросов и ответов, методы запросов, коды ответов сервера, заголовки запросов и ответов.**

#### 1. Что такое HTTP?

**Формальное определение:** **HTTP (HyperText Transfer Protocol)** — это протокол прикладного уровня для передачи данных в сети. Он является основой для обмена информацией во Всемирной паутине (World Wide Web). HTTP работает по модели "клиент-сервер", где клиент (обычно веб-браузер) отправляет запрос, а сервер (где расположен сайт) возвращает ответ.

**Простыми словами:** Представьте, что вы в библиотеке. Вы (клиент) пишете записку библиотекарю (серверу) с просьбой: "Пожалуйста, дайте мне книгу 'Война и мир', том первый". Эта записка — **HTTP-запрос**. Библиотекарь находит книгу и приносит ее вам вместе с ответом: "Вот ваша книга". Книга с ответом — это **HTTP-ответ**. HTTP — это язык и правила, по которым составлена ваша записка и ответ библиотекаря, чтобы вы точно поняли друг друга.

#### 2. Структура HTTP-запроса

Каждый раз, когда вы кликаете по ссылке или отправляете форму, ваш браузер формирует HTTP-запрос, который состоит из четырех частей:

1.  **Стартовая строка (Request Line):** Самая первая строка, говорит серверу, что вы хотите.
    *   **Метод:** Что сделать с ресурсом (`GET`, `POST` и т.д.).
    *   **URI (путь):** Адрес ресурса на сервере (например, `/calculate` в твоей ЛР).
    *   **Версия протокола:** Обычно `HTTP/1.1`.
    *   *Пример из твоей ЛР:* `POST /calculate HTTP/1.1`

2.  **Заголовки (Headers):** Дополнительная информация о запросе в формате "Ключ: Значение".
    *   `Host: localhost:8080` — К какому серверу обращаемся.
    *   `Content-Type: application/x-www-form-urlencoded` — В каком формате отправлены данные в теле.
    *   `Content-Length: 15` — Размер тела запроса в байтах.
    *   `User-Agent: Mozilla/5.0 ...` — Информация о вашем браузере.

3.  **Пустая строка:** Обязательный разделитель между заголовками и телом запроса.

4.  **Тело запроса (Body):** Сами данные, которые вы отправляете. Эта часть есть не у всех запросов (например, у `GET` ее нет).
    *   *Пример из твоей ЛР:* `x=1&y=2.5&r=3`

#### 3. Структура HTTP-ответа

После обработки запроса сервер отправляет ответ, который устроен очень похоже:

1.  **Строка состояния (Status Line):** Первая строка ответа.
    *   **Версия протокола:** `HTTP/1.1`
    *   **Код состояния:** Трехзначное число, говорящее о результате (`200`, `404`).
    *   **Текст состояния:** Человекопонятное описание кода (`OK`, `Not Found`).
    *   *Пример успешного ответа из твоей ЛР:* `HTTP/1.1 200 OK`
    *   *Пример ответа с ошибкой:* `HTTP/1.1 400 Bad Request`

2.  **Заголовки (Headers):** Информация об ответе.
    *   `Content-Type: application/json` — В каком формате данные в теле ответа.
    *   `Content-Length: 85` — Размер тела ответа.
    *   `Server: Apache/2.4.62` — Какой веб-сервер обработал запрос.
    *   `Date: Mon, 29 Sep 2025 ...` — Дата и время отправки ответа.

3.  **Пустая строка:** Разделитель.

4.  **Тело ответа (Body):** Запрошенные данные (HTML-страница, картинка, JSON-строка).
    *   *Пример из твоей ЛР:* `{"x":1.0,"y":2.5,"r":3.0,"hit":true,...}`

#### 4. Методы запросов

Метод указывает на основную операцию, которую нужно совершить над ресурсом.
*   **`GET`:** Запросить ресурс. Используется для получения данных (например, загрузка HTML-страницы). Безопасен, так как не должен изменять состояние сервера.
*   **`POST`:** Отправить данные на сервер для создания нового ресурса или для обработки. Используется для отправки форм. *Именно этот метод ты использовал в своей ЛР для отправки координат.*
*   **`HEAD`:** То же, что и `GET`, но сервер возвращает только заголовки без тела ответа. Полезно для проверки, существует ли ресурс, без его скачивания.
*   **`PUT`:** Полностью заменяет ресурс по указанному URI данными из тела запроса. Если ресурса нет, он может быть создан.
*   **`DELETE`:** Удаляет указанный ресурс.
*   **`PATCH`:** Применяет частичные изменения к ресурсу.
*   **`OPTIONS`:** Запрашивает информацию о возможностях сервера для указанного ресурса (например, какие методы он поддерживает).

#### 5. Коды состояния HTTP

Это стандартизированные коды, которые кратко сообщают о результате обработки запроса. Они делятся на 5 классов по первой цифре:

*   **`1xx` (Информационные):** Запрос получен, процесс продолжается. (Редко встречаются).
*   **`2xx` (Успех):** Запрос был успешно получен, понят и принят.
    *   `200 OK`: Стандартный успешный ответ.
    *   `201 Created`: Ресурс был успешно создан (в ответ на `POST` или `PUT`).
*   **`3xx` (Перенаправление):** Клиенту нужно предпринять дальнейшие шаги для выполнения запроса.
    *   `301 Moved Permanently`: Ресурс навсегда переехал на новый URL.
*   **`4xx` (Ошибка клиента):** Запрос составлен некорректно или не может быть выполнен.
    *   `400 Bad Request`: Сервер не понял запрос из-за синтаксической ошибки. *Твой Java-сервер возвращает этот статус при невалидных данных.*
    *   `403 Forbidden`: Доступ к ресурсу запрещен.
    *   `404 Not Found`: Сервер не может найти запрошенный ресурс.
*   **`5xx` (Ошибка сервера):** Сервер не смог выполнить корректно составленный запрос.
    *   `500 Internal Server Error`: Внутренняя ошибка на сервере, которую он не смог обработать.

---

### **Вопрос: Язык разметки HTML. Особенности, основные теги и атрибуты тегов.**

#### 1. Что такое HTML?

**Формальное определение:** **HTML (HyperText Markup Language)** — это стандартизированный язык семантической разметки документов для просмотра веб-страниц в браузере. HTML не является языком программирования, так как в нем нет логики (циклов, условий). Он лишь описывает структуру и содержание документа.

**Простыми словами:** HTML — это как скелет для веб-страницы. Он говорит браузеру: "Вот это — главный заголовок, это — абзац текста, это — картинка, а это — ссылка на другую страницу". Он создает каркас, на который потом с помощью CSS "навешивают" внешний вид, а с помощью JavaScript "оживляют".

#### 2. Особенности HTML

*   **Теговая структура:** Документ строится из **элементов**, которые обозначаются **тегами**. Большинство тегов парные: открывающий (`<p>`) и закрывающий (`</p>`). Есть и одиночные теги, например `<br>` (перенос строки) или `<img>` (картинка).
*   **Вложенность:** Теги могут вкладываться друг в друга, создавая иерархическую структуру (дерево DOM).
*   **Атрибуты:** Теги могут иметь атрибуты, которые предоставляют дополнительную информацию об элементе, например `<a href="page.html">`.
*   **Семантика:** Современный HTML5 делает упор на использование тегов, которые описывают **смысл** содержимого, а не просто его вид. Например, вместо `<div>` для шапки сайта лучше использовать `<header>`. Это помогает поисковым системам и программам для людей с ограниченными возможностями лучше понимать структуру страницы.

#### 3. Основные теги и атрибуты

**Структурные теги:**
*   `<!DOCTYPE html>`: Объявляет тип документа.
*   `<html>`: Корневой элемент всей страницы.
*   `<head>`: Содержит мета-информацию (заголовок, стили).
*   `<body>`: Содержит все видимое содержимое страницы.
*   `<header>`, `<main>`, `<footer>`, `<nav>`, `<section>`, `<article>`: Семантические теги для разметки крупных блоков.
*   `<div>`: Универсальный блочный контейнер без семантического смысла.
*   `<span>`: Универсальный строчный контейнер.

**Теги для контента:**
*   `<h1>`...`<h6>`: Заголовки разных уровней.
*   `<p>`: Абзац текста.
*   `<a>`: Ссылка. Основной атрибут — **`href`**, содержащий URL.
*   `<img>`: Изображение. Основные атрибуты — **`src`** (путь к файлу) и **`alt`** (альтернативный текст).
*   `<ul>`, `<ol>`, `<li>`: Маркированные и нумерованные списки и их элементы.
*   `<table>`, `<tr>`, `<th>`, `<td>`: Таблица, строка, заголовочная ячейка, обычная ячейка. *Ты использовал их для вывода результатов.*

**Атрибуты:**
*   **`id`**: Уникальный идентификатор элемента на всей странице. *Пример: `<div id="main-content">`.*
*   **`class`**: Имя класса, которое можно присвоить нескольким элементам для их группировки и стилизации. *Пример: `<div class="panel">`.*
*   **`style`**: Для добавления "встроенных" CSS-стилей (считается плохой практикой).
*   **`src`**, **`href`**: Указывают путь к ресурсу.
*   **`name`**, **`value`**, **`type`**: Атрибуты полей форм.

---

### **Вопрос: Структура HTML-страницы. Объектная модель документа (DOM).**

#### 1. Структура HTML-страницы

Любая HTML-страница имеет строгую иерархическую структуру, похожую на родословное дерево:

```html
<!DOCTYPE html>
<html lang="ru"> <!-- Корневой элемент, "прародитель" -->
  <head> <!-- Первый "ребенок" html -->
    <meta charset="UTF-8">
    <title>Заголовок страницы</title>
  </head>
  <body> <!-- Второй "ребенок" html -->
    <header> <!-- "Ребенок" body -->
      <h1>Главный заголовок</h1> <!-- "Ребенок" header -->
    </header>
  </body>
</html>
```
*   **`<!DOCTYPE html>`**: Это не тег, а инструкция для браузера, говорящая, что он имеет дело с документом стандарта HTML5.
*   **`<html>`**: Корневой элемент, который содержит все остальное.
*   **`<head>`**: "Голова" документа. Ее содержимое не отображается на странице напрямую (кроме `<title>`), но содержит важную служебную информацию: кодировку, заголовок вкладки, подключение CSS-стилей и JS-скриптов.
*   **`<body>`**: "Тело" документа. Здесь находится всё, что пользователь видит на странице: тексты, картинки, таблицы, формы.

#### 2. Объектная модель документа (DOM)

**Формальное определение:** **DOM (Document Object Model)** — это не зависящий от платформы и языка программный интерфейс (API), который позволяет программам и скриптам получать доступ к содержимому HTML-документа и изменять его содержимое, структуру и оформление.

**Простыми словами:** Когда браузер загружает ваш HTML-код, он не просто показывает его как текст. Он строит в своей памяти **объектное представление** этого кода в виде дерева. Это дерево и называется DOM. Каждый тег, каждый атрибут, каждый кусочек текста в вашем HTML становится **узлом (node)** или **объектом** в этом дереве.

*   **Зачем это нужно?** DOM — это мост между статичным HTML-кодом и динамичным языком программирования, таким как **JavaScript**. JavaScript не может работать напрямую с вашим `.html` файлом. Но он может работать с DOM.
*   **Что можно делать с DOM?**
    *   **Находить узлы:** `document.getElementById('results-table')` находит в дереве объект, соответствующий вашей таблице.
    *   **Изменять узлы:** Можно поменять текст внутри элемента, его атрибуты или стили.
    *   **Добавлять новые узлы:** `resultsTableBody.insertRow(0)` создает новый объект-строку и вставляет его в дерево DOM, и вы тут же видите новую строку на странице.
    *   **Удалять узлы:** `resultsTableBody.innerHTML = ''` удаляет все дочерние узлы из тела таблицы.

**Ключевая мысль:** Любое изменение, которое ваш JavaScript вносит в страницу (показ ошибки, добавление строки в таблицу, отрисовка точки на графике), — это на самом деле **манипуляция с объектами в дереве DOM**.

---

### **Вопрос: HTML-формы. Задание метода HTTP-запроса. Правила размещения форм на страницах, виды полей ввода.**

#### 1. Что такое HTML-формы?

**Определение:** HTML-форма — это раздел документа, предназначенный для сбора и отправки данных от пользователя на веб-сервер. Формы являются основным инструментом для интерактивного взаимодействия с сайтом.

**Простыми словами:** Форма — это анкета на веб-странице, которую пользователь заполняет (вводит текст, выбирает опции), а затем нажимает кнопку, чтобы отправить эту анкету на сервер для обработки. *Вся левая панель в твоей ЛР — это одна большая HTML-форма.*

#### 2. Задание формы и метода HTTP-запроса

Форма создается с помощью тега `<form>`. У него есть два важнейших атрибута:

*   **`action`**: Указывает URL-адрес серверного скрипта, который будет обрабатывать данные формы. Если `action` не указан, данные отправятся на URL текущей страницы.
*   **`method`**: Указывает, какой **метод HTTP-запроса** использовать для отправки данных.
    *   `method="GET"` (по умолчанию): Данные формы добавляются в конец URL, указанного в `action`, в виде `ключ=значение`. Пример: `http://example.com/search?query=web&page=1`. Подходит для поисковых форм, не изменяющих данные на сервере.
    *   `method="POST"`: Данные формы отправляются в **теле HTTP-запроса**. Этот метод используется, когда нужно отправить большой объем данных, файлы или когда отправка данных приводит к изменению состояния на сервере (создание записи в БД, отправка сообщения). *Именно этот метод требуется в твоей ЛР и является стандартом для отправки форм.*

#### 3. Правила размещения и виды полей

**Правила:**
*   Форма может находиться в любом месте внутри `<body>`.
*   Все элементы управления (`<input>`, `<button>` и т.д.), данные из которых должны быть отправлены, должны находиться **внутри** тега `<form>`.

**Основные виды полей ввода:**
Элементы управления формой, в основном, создаются тегом `<input>` с разными значениями атрибута `type`.

*   **`<input type="text">`**: Однострочное текстовое поле. *Ты использовал его для Y.*
*   **`<input type="number">`**: Поле для ввода чисел. Удобно на мобильных, так как открывает цифровую клавиатуру.
*   **`<input type="password">`**: Поле для пароля, вводимые символы маскируются.
*   **`<input type="radio">`**: Радиокнопка. Позволяет выбрать **только один** вариант из группы кнопок с одинаковым атрибутом `name`. *Используется тобой для выбора X.*
*   **`<input type="checkbox">`**: Флажок (чекбокс). Позволяет выбрать **ноль или несколько** вариантов.
*   **`<input type="hidden">`**: Скрытое поле. Пользователь его не видит, но его значение отправляется на сервер. *Ты используешь его для хранения выбранного значения R.*
*   **`<input type="file">`**: Поле для выбора файла для загрузки на сервер.
*   **`<button type="submit">` или `<input type="submit">`**: Кнопка, нажатие на которую инициирует отправку формы.
*   **`<button type="button">`**: Обычная кнопка без действия по умолчанию. Ее поведение обычно определяется с помощью JavaScript. *Ты используешь такие кнопки для выбора R.*
*   **`<textarea>`**: Многострочное текстовое поле.
*   **`<select>` и `<option>`**: Выпадающий список.

---

### **Вопрос: Каскадные таблицы стилей (CSS). Структура - правила, селекторы. Виды селекторов, особенности их применения. Приоритеты правил. Преимущества CSS перед непосредственным заданием стилей через атрибуты тегов.**

#### 1. Что такое CSS?

**Формальное определение:** **CSS (Cascading Style Sheets)** — это формальный язык описания внешнего вида документа, написанного с использованием языка разметки (например, HTML). CSS используется для задания цветов, шрифтов, отступов, расположения блоков и других аспектов представления документа.

**Простыми словами:** Если HTML — это скелет страницы, то CSS — это ее "одежда" и "макияж". CSS отвечает на вопросы: "Какого цвета должен быть заголовок?", "Каким шрифтом написан текст?", "Где на странице расположена эта картинка?".

Ключевая концепция CSS — **отделение содержания (HTML) от представления (CSS)**. Это делает код гораздо чище, гибче и проще в поддержке.

#### 2. Структура CSS-правила

Любой CSS-код состоит из набора правил. Каждое правило имеет две части:

`селектор { свойство: значение; }`

*   **Селектор:** Указывает, к какому HTML-элементу (или элементам) применить стиль.
*   **Блок объявлений:** Находится в фигурных скобках `{}` и содержит одно или несколько объявлений.
*   **Объявление:** Состоит из **свойства** (например, `color`) и его **значения** (например, `red`), разделенных двоеточием и заканчивающихся точкой с запятой.

*Пример:* `h1 { color: blue; font-size: 24px; }`
*   **Селектор:** `h1`
*   **Свойства:** `color`, `font-size`
*   **Значения:** `blue`, `24px`

#### 3. Виды селекторов

Селекторы — это мощнейший инструмент CSS. Вот основные из них:

*   **По тегу:** `p` — выберет все теги `<p>`.
*   **По классу:** `.panel` — выберет все элементы с атрибутом `class="panel"`. Самый распространенный и гибкий способ.
*   **По ID:** `#main-form` — выберет **единственный** элемент с `id="main-form"`. ID должен быть уникальным на странице.
*   **Универсальный селектор:** `*` — выберет абсолютно все элементы.
*   **Селектор атрибута:** `input[type="radio"]` — выберет все `<input>`, у которых атрибут `type` равен `"radio"`.
*   **Комбинаторы:**
    *   **Селектор потомка:** `div p` — выберет все `<p>`, которые находятся **внутри** `<div>`, на любом уровне вложенности.
    *   **Дочерний селектор:** `div > p` — выберет только те `<p>`, которые являются **прямыми потомками** `<div>`.
    *   **Соседний селектор:** `h1 + p` — выберет `<p>`, который идет **сразу после** `<h1>` на том же уровне.
*   **Псевдоклассы:** Описывают особое состояние элемента.
    *   `:hover` — когда курсор мыши наведен на элемент.
    *   `:focus` — когда элемент в фокусе (например, поле ввода, в которое кликнули).
    *   `:checked` — для выбранных `<input type="radio">` или `<input type="checkbox">`.

#### 4. Приоритеты правил (Каскад)

"Каскадность" в названии CSS означает, что стили "стекают" вниз по иерархии приоритетов. Если для одного элемента подходят несколько правил, браузер решит, какое применить, по "весу" селектора:

1.  **`!important`:** Правило с `!important` (например, `color: red !important;`) перебивает все остальные. Использовать его следует в крайних случаях.
2.  **Встроенные стили (Inline styles):** Стиль, заданный прямо в атрибуте `style` (`<p style="color: red;">`). Имеет наивысший приоритет после `!important`.
3.  **Вес селектора:**
    *   **ID (`#id`):** Самый "тяжелый" селектор.
    *   **Классы (`.class`), атрибуты (`[type=...]`), псевдоклассы (`:hover`):** Средний вес.
    *   **Теги (`p`, `div`):** Самый низкий вес.

**Простое правило:** Чем точнее селектор указывает на элемент, тем выше его приоритет. Правило `#main-content .panel h1` будет "сильнее", чем просто `h1`.

#### 5. Преимущества CSS перед атрибутом `style`

1.  **Разделение ответственности:** HTML занимается структурой, CSS — внешним видом. Код становится чище.
2.  **Переиспользование:** Вы можете написать один класс `.button` и применить его к сотне кнопок. С атрибутом `style` вам пришлось бы скопировать стили сто раз.
3.  **Легкость поддержки:** Чтобы изменить цвет всех кнопок на сайте, нужно поменять **одну строку** в CSS-файле. При использовании `style` пришлось бы искать и менять каждую кнопку в HTML.
4.  **Больше возможностей:** CSS позволяет использовать псевдоклассы (`:hover`), медиа-запросы (для адаптации под разные экраны) и анимации, что невозможно сделать через атрибут `style`.

---

### **Вопрос: LESS, Sass, SCSS. Ключевые особенности, сравнительные характеристики. Совместимость с браузерами, трансляция в "обычный" CSS.**

#### 1. Что это такое?

**LESS, Sass и SCSS** — это **CSS-препроцессоры**.

**Формальное определение:** CSS-препроцессор — это язык-надстройка над CSS, который расширяет его синтаксис, добавляя возможности, присущие языкам программирования, такие как переменные, вложенность, миксины и функции.

**Простыми словами:** Представьте, что обычный CSS — это простой текстовый редактор, а препроцессор — это Microsoft Word. Препроцессоры дают вам "суперсилы" для написания CSS: вы можете создавать переменные для цветов, чтобы не копировать их HEX-коды по сто раз, вкладывать правила друг в друга для удобства и создавать переиспользуемые блоки стилей.

#### 2. Ключевые особенности (что они умеют)

*   **Переменные:** Можно сохранить значение (например, цвет или размер шрифта) в переменную и использовать ее по всему файлу.
    *   *SCSS/Sass:* `$primary-color: #8a4baf;`
    *   *LESS:* `@primary-color: #8a4baf;`
*   **Вложенность (Nesting):** Позволяет писать CSS-правила, повторяя HTML-структуру, что делает код намного чище и понятнее.
    ```scss
    // SCSS
    nav {
      ul {
        margin: 0;
        li {
          display: inline-block;
          a {
            color: blue;
          }
        }
      }
    }
    ```
*   **Миксины (Mixins):** Позволяют создавать переиспользуемые блоки CSS-правил. Это как функция, которую можно вызвать в любом селекторе. Sass/SCSS в этом плане мощнее.
*   **Наследование (`@extend`):** Позволяет одному селектору "унаследовать" все стили другого.
*   **Математические и цветовые операции:** Можно складывать, вычитать, умножать и делить значения, а также осветлять, затемнять или смешивать цвета.

#### 3. Сравнительные характеристики

*   **Sass vs SCSS:** Это два синтаксиса **одного и того же препроцессора (Sass)**.
    *   **Sass (старый синтаксис):** Очень лаконичный, использует отступы вместо `{}` и переносы строк вместо `;`. Похож на Python или Ruby.
    *   **SCSS (Sassy CSS):** **Полностью совместим с синтаксисом обычного CSS.** Любой валидный CSS-файл является валидным SCSS-файлом. Это сделало его **гораздо более популярным**, так как на него легко перейти. **Сегодня, говоря "Sass", почти всегда имеют в виду синтаксис SCSS.**
*   **Sass/SCSS vs LESS:**
    *   **Функциональность:** **Sass/SCSS считается более мощным.** В нем есть полноценная логика: условия (`@if/@else`) и циклы (`@for`, `@each`), которых нет в LESS.
    *   **Язык:** Изначально Sass был написан на Ruby, что делало его установку сложнее. Современные реализации на Dart и C++ очень быстрые. LESS написан на JavaScript.

#### 4. Совместимость с браузерами и трансляция

**Это ключевой момент:** **Браузеры не понимают синтаксис LESS, Sass или SCSS.** Они понимают только обычный, "ванильный" CSS.

Поэтому код, написанный на препроцессоре, должен быть **скомпилирован** (или **транслирован**) в обычный CSS-файл перед тем, как он будет использован на сайте.

*   **Как это работает:** На этапе разработки вы пишете код в файлах `.scss` или `.less`.
*   Специальная программа-компилятор (или сборщик проектов вроде Webpack/Gulp) следит за изменениями в этих файлах.
*   Каждый раз, когда вы сохраняете `.scss` файл, компилятор автоматически генерирует на его основе обычный `.css` файл.
*   Именно этот сгенерированный `.css` файл вы подключаете к вашей HTML-странице.
*   **Итог:** На старых (и на любых) браузерах все работает отлично, потому что они получают на вход обычный, понятный им CSS.

---

### **Вопрос: Клиентские сценарии. Особенности, сферы применения. Язык JavaScript.**

#### 1. Что такое клиентские сценарии?

**Формальное определение:** **Клиентские сценарии (Client-side scripting)** — это программный код, который выполняется на стороне клиента, то есть непосредственно в веб-браузере пользователя, после того как веб-страница была загружена с сервера.

**Простыми словами:** Это "мозг" вашей веб-страницы, который работает прямо у вас в компьютере. Когда вы нажимаете на кнопку и что-то происходит без перезагрузки страницы, — это работа клиентского сценария. Он делает страницу "живой" и интерактивной.

#### 2. Язык JavaScript

**JavaScript (JS)** — это основной, самый популярный и, по сути, единственный язык программирования, на котором пишутся клиентские сценарии для веба.

**Основные архитектурные черты:**
*   **Динамическая типизация:** Тип переменной определяется в момент присвоения ей значения, его не нужно объявлять заранее. `let x = 10;` (x - число), `x = "привет";` (теперь x - строка).
*   **Автоматическое управление памятью:** JavaScript сам выделяет память под объекты и сам очищает ее с помощью механизма "сборки мусора", когда объект становится недоступным.
*   **Прототипное программирование:** В отличие от классических языков (Java, C++), в JS наследование объектов строится не на классах, а на **прототипах**. Каждый объект может иметь объект-прототип, от которого он наследует свойства и методы. (Хотя в современных версиях JS появились `class`, это лишь "синтаксический сахар" над прототипами).
*   **Функции как объекты первого класса:** Это означает, что с функциями можно обращаться как с обычными данными: их можно присваивать переменным, передавать в другие функции в качестве аргументов и возвращать из функций. Это основа функционального программирования в JS.

#### 3. Сферы применения

*   **Манипуляция DOM:** Главная задача JS. Изменение HTML и CSS на лету для создания динамического интерфейса. *Именно это делает твой `script.js` при добавлении строк в таблицу.*
*   **Валидация форм:** Проверка данных, введенных пользователем, на корректность **до** отправки на сервер. Это экономит время и ресурсы. *Твой скрипт проверяет, что Y — это число в нужном диапазоне.*
*   **Асинхронные запросы (AJAX):** Отправка и получение данных с сервера в фоновом режиме, без перезагрузки страницы. *Ключевая часть твоей ЛР.*
*   **Обработка событий:** Реакция на действия пользователя — клики, наведение мыши, нажатия клавиш, отправка формы.
*   **Создание сложных интерфейсов:** Вся современная веб-разработка (фреймворки React, Angular, Vue) построена на JavaScript для создания полноценных одностраничных приложений (SPA).

---

### **Вопрос: Версии ECMAScript, новые возможности ES6 и ES7.**

#### 1. Что такое ECMAScript?

**Формальное определение:** **ECMAScript (ES)** — это стандарт, спецификация, которая определяет, как должен работать скриптовый язык.

**Простыми словами:** ECMAScript — это как ГОСТ для языка JavaScript. Эта "книга правил" описывает, какой в языке должен быть синтаксис, какие типы данных, какие встроенные объекты и функции. **JavaScript** — это самая известная и популярная **реализация** этого стандарта. Другие реализации, например, JScript от Microsoft, тоже существуют.

Версии стандарта именуются либо по номеру (ES5, ES6), либо по году выпуска (ES2015, ES2016).

#### 2. ES5 (ECMAScript 2009)

Это старый стандарт, который очень долго был основным в веб-разработке. В нем переменные объявлялись только через `var`, что имело свои проблемы с областями видимости.

#### 3. ES6 (ECMAScript 2015)

Это **революционное** и самое большое обновление в истории JavaScript, которое сделало язык гораздо более мощным и удобным.

**Ключевые новые возможности:**
*   **`let` и `const`:** Новые способы объявления переменных. `let` создает переменную с **блочной** областью видимости (внутри `{}`), что решает многие проблемы `var`. `const` создает константу, значение которой нельзя изменить.
*   **Стрелочные функции (Arrow Functions):** Более короткий синтаксис для написания функций.
    *   *Было:* `function(a, b) { return a + b; }`
    *   *Стало:* `(a, b) => a + b;`
*   **Классы (Classes):** Введен синтаксис `class User { ... }` для создания объектов, который гораздо привычнее для программистов из других языков (хотя под капотом все еще прототипы).
*   **Промисы (Promises):** Стандартный и гораздо более удобный способ работы с асинхронными операциями, чем старые "callback hell". `fetch`, который ты использовал, возвращает именно Промис.
*   **Модули (`import`/`export`):** Стандартный способ разделения кода на несколько файлов и их импорта/экспорта.
*   **Шаблонные строки (Template Literals):** Позволяют легко вставлять переменные в строки с помощью обратных кавычек `` \` ``.
    *   *Пример:* `` `Привет, ${userName}!` ``
*   **Цикл `for...of`:** Удобный способ перебора итерируемых объектов (массивов, строк).

#### 4. ES7 (ECMAScript 2016)

Это было гораздо меньшее обновление, так как было решено выпускать новые версии стандарта каждый год с небольшими добавлениями.

**Основные нововведения:**
*   **Оператор возведения в степень (`**`):** `2 ** 3` (два в третьей степени) вернет `8`.
*   **Метод `Array.prototype.includes()`:** Простой и читаемый способ проверить, есть ли элемент в массиве.
    *   *Было:* `myArray.indexOf(element) !== -1`
    *   *Стало:* `myArray.includes(element)`

---

### **Вопрос: Синхронная и асинхронная обработка HTTP-запросов. AJAX.**

#### 1. Синхронная обработка

Представьте, что вы звоните в пиццерию. При **синхронном** звонке вы набираете номер и **держите трубку у уха, молча ожидая, пока пиццу приготовят, привезут и отдадут вам в руки**. Все это время вы не можете делать ничего другого — ни смотреть телевизор, ни разговаривать с кем-то еще. Ваш мир "завис" в ожидании ответа.

В JavaScript это означает, что когда отправляется синхронный запрос, **выполнение всего кода останавливается**, и **интерфейс браузера "замерзает"**. Пользователь не может нажимать на кнопки, скроллить страницу, ничего. Это очень плохой пользовательский опыт, поэтому синхронные запросы практически никогда не используются.

#### 2. Асинхронная обработка

При **асинхронном** звонке в пиццерию вы делаете заказ, **кладете трубку и идете заниматься своими делами**. Вы договорились, что когда пицца будет готова, курьер вам позвонит в дверь. Вы не тратите время на ожидание.

В JavaScript это означает, что вы отправляете запрос на сервер и **не ждете ответа**. Код продолжает выполняться, страница остается полностью интерактивной. Вы просто "говорите" браузеру: "Когда придет ответ, выполни вот эту функцию". Эта функция (callback, обработчик `.then()` у промиса) и есть тот самый "звонок в дверь".

**Это основа современного веба.**

#### 3. AJAX

**Формальное определение:** **AJAX (Asynchronous JavaScript and XML)** — это подход к построению интерактивных веб-приложений, заключающийся в **асинхронном ("фоновом") обмене данными** между браузером и веб-сервером. В результате веб-страница может обновлять свое содержимое **без полной перезагрузки**.

**Простыми словами:** AJAX — это технология, которая позволяет "асинхронной магии" происходить. Это не конкретный язык, а **концепция**, которая объединяет несколько технологий:
*   HTML/CSS для представления данных.
*   DOM для динамического отображения и взаимодействия.
*   JSON или XML для обмена данными (сегодня почти всегда JSON).
*   Объект `XMLHttpRequest` (старый способ) или `fetch` API (современный способ) для асинхронной связи с сервером.
*   JavaScript, чтобы все это связать воедино.

**Как это работает в твоей ЛР:**
1.  Ты нажимаешь кнопку "Проверить".
2.  JavaScript **асинхронно** отправляет `POST`-запрос с данными на `/calculate` с помощью `fetch`.
3.  Страница **не перезагружается**. Ты можешь дальше кликать по кнопкам (хотя и не успеешь).
4.  Твой Java-сервер обрабатывает запрос и возвращает JSON-ответ.
5.  Когда ответ приходит, срабатывает обработчик `.then()` в твоем JS-коде.
6.  JavaScript парсит JSON и с помощью **манипуляций с DOM** добавляет новую строку в таблицу.

Весь процесс произошел "за кулисами", плавно и без прерывания работы пользователя. **Это и есть AJAX.**

---

### **Вопрос: Библиотека jQuery. Назначение, основные API. Использование для реализации AJAX и работы с DOM.**

#### 1. Что такое jQuery?

**Формальное определение:** **jQuery** — это быстрая, небольшая и многофункциональная библиотека JavaScript, которая значительно упрощает взаимодействие с HTML-документом, обработку событий, создание анимаций и работу с AJAX-запросами.

**Простыми словами:** jQuery — это как швейцарский нож для JavaScript-разработчика (особенно в прошлом). До появления ES6 и современных браузерных API, работа с DOM и AJAX в "чистом" JavaScript была очень громоздкой и требовала написания разного кода для разных браузеров. jQuery предоставила простой, короткий и кросс-браузерный способ делать все то же самое. Ее девиз: **"Пиши меньше, делай больше"**.

#### 2. Основные API

Вся работа с jQuery строится вокруг функции `$` (знак доллара).

*   **Выборка элементов (DOM Traversal):** `$('селектор')`
    *   Это самая мощная часть jQuery. Она позволяет находить элементы с помощью синтаксиса CSS-селекторов.
    *   *Пример:* `$('#main-form')` вернет объект jQuery, содержащий вашу форму. `$('.panel')` вернет все элементы с классом `panel`.
*   **Манипуляция DOM:**
    *   `.html()` / `.text()`: Получить или изменить HTML-содержимое или текст элемента.
    *   `.append()` / `.prepend()`: Добавить элемент в конец или в начало другого элемента.
    *   `.addClass()` / `.removeClass()`: Добавить или удалить CSS-класс.
    *   `.css('свойство', 'значение')`: Изменить CSS-свойство.
    *   `.show()` / `.hide()`: Показать или скрыть элемент.
*   **Обработка событий:**
    *   `.on('click', function() { ... })`: Привязать обработчик к событию. Есть и короткие версии: `.click(...)`, `.hover(...)`.

#### 3. Использование для AJAX

jQuery предоставляет очень удобную "обертку" для выполнения AJAX-запросов — функцию `$.ajax()`.

```javascript
// Пример AJAX-запроса на jQuery, аналог твоего fetch
$.ajax({
  type: "POST", // Метод запроса
  url: "/calculate", // URL-адрес
  data: { x: 1, y: 2.5, r: 3 }, // Данные (jQuery сама их отформатирует)
  success: function(response) {
    // Эта функция выполнится при успешном ответе (статус 2xx)
    // 'response' - это уже готовый распарсенный JSON-объект
    console.log("Сервер ответил:", response);
    // Здесь был бы код для добавления строки в таблицу
  },
  error: function(jqXHR, textStatus, errorThrown) {
    // Эта функция выполнится при ошибке (статус 4xx, 5xx)
    console.error("Произошла ошибка:", textStatus);
  }
});
```
Как видишь, синтаксис очень декларативный и понятный. До появления `fetch`, `$.ajax()` был золотым стандартом для AJAX-запросов.

**Актуальность сегодня:** Популярность jQuery снизилась, так как современный "ванильный" JavaScript (с `querySelector` и `fetch`) стал таким же удобным и не требует подключения сторонней библиотеки. Но знать о jQuery необходимо, так как огромное количество старых проектов написано на ней.

---

### **Вопрос: Реализация AJAX с помощью SuperAgent.**

(Этот вопрос выходит за рамки твоей ЛР, но для общего развития полезен).

**SuperAgent** — это еще одна библиотека для выполнения HTTP-запросов, как `fetch` или `$.ajax`. Она популярна как в браузере, так и на серверной стороне в среде Node.js.

**Ее главная фишка** — очень удобный, читаемый и **"цепочечный" (chainable) синтаксис**. Вы как будто строите свой запрос по кирпичикам, вызывая методы один за другим.

**Пример реализации AJAX:**
Давайте представим, что мы отправляем тот же запрос из твоей ЛР, но с помощью SuperAgent.

```javascript
// Подключение библиотеки (обычно через import)
import request from 'superagent';

// Отправка запроса
request
  .post('/calculate') // 1. Указываем метод и URL
  .type('form') // 2. Указываем тип отправляемых данных (как application/x-www-form-urlencoded)
  .send({ x: 1, y: 2.5, r: 3 }) // 3. Прикрепляем данные
  .set('Accept', 'application/json') // 4. Устанавливаем заголовок
  .then(response => {
    // 5. Обрабатываем успешный ответ (как .then у fetch)
    // response.body - это уже готовый распарсенный JSON-объект
    console.log('Успешный ответ:', response.body);
    // Здесь был бы код для обновления таблицы
  })
  .catch(error => {
    // 6. Обрабатываем ошибку (как .catch у fetch)
    console.error('Ошибка запроса:', error);
  });
```

**Сравнение с `fetch`:**
*   SuperAgent — это более высокоуровневая библиотека. Она предоставляет больше удобств "из коробки" (например, автоматический парсинг JSON в `.body`).
*   Синтаксис SuperAgent многим кажется более читаемым и декларативным, чем `fetch` с его обработкой `response.ok` и `response.json()`.
*   `fetch` — это **встроенный в браузер стандарт**, он не требует подключения сторонних библиотек. SuperAgent — это зависимость, которую нужно добавлять в проект.

Для простых задач, как в твоей ЛР, `fetch` более чем достаточно. SuperAgent удобен в более сложных проектах, где нужно много работать с HTTP-запросами.

---

### **Вопрос: Серверные сценарии. CGI - определение, назначение, ключевые особенности.**

#### 1. Что такое серверные сценарии?

**Формальное определение:** **Серверные сценарии (Server-side scripting)** — это технология, которая позволяет выполнять программный код на стороне веб-сервера для генерации динамического контента в ответ на запрос клиента.

**Простыми словами:** Веб-сервер, как Apache, сам по себе умеет только отдавать готовые файлы (HTML, CSS, картинки). Это **статический контент**. Но если вам нужно показать на странице текущее время, погоду или результаты из базы данных, вам нужен **динамический контент**. Серверные сценарии — это программы (на Java, PHP, Python), которые запускаются на сервере, выполняют какую-то логику (считают, лезут в базу данных) и генерируют уникальный HTML-ответ специально для этого запроса.

#### 2. CGI - Общий шлюзовой интерфейс

**Формальное определение:** **CGI (Common Gateway Interface)** — это стандартный протокол (набор правил), который определяет, как веб-сервер должен взаимодействовать с внешней программой-сценарием для обработки запроса.

**Простыми словами:** CGI — это самый первый "переводчик" между веб-сервером и внешней программой. Apache сам не знает, как запустить твой Java-код. CGI — это инструкция для Apache, которая говорит: "Когда придет запрос на этот адрес, запусти вот эту программу, передай ей данные из запроса вот таким способом, а то, что программа напечатает в ответ, — отправь обратно клиенту".

#### 3. Ключевые особенности и принцип работы CGI

Принцип работы CGI — **"один запрос — один новый процесс"**.

1.  Клиент отправляет запрос на сервер (например, `GET /cgi-bin/my-script`).
2.  Веб-сервер Apache видит, что это запрос к CGI-скрипту.
3.  Apache **запускает совершенно новый процесс операционной системы** для выполнения этого скрипта.
4.  Данные из HTTP-запроса (URL, заголовки) передаются в этот новый процесс через **переменные окружения**. Тело запроса (если есть) передается через **стандартный поток ввода (stdin)**.
5.  Программа-скрипт выполняется, делает свою работу.
6.  Результат (готовый HTML или другой контент) программа печатает в **стандартный поток вывода (stdout)**. Важно, что программа сама должна сформировать HTTP-заголовки (`Content-Type: text/html`).
7.  Apache "ловит" все, что было напечатано в stdout, и отправляет это клиенту как HTTP-ответ.
8.  Как только скрипт завершил работу, **процесс, в котором он выполнялся, полностью уничтожается.**

**Главный недостаток:** Создание и уничтожение процесса операционной системы на **каждый** запрос — это **невероятно медленно и ресурсозатратно**. Для языков с "тяжелой" средой выполнения, как Java (которой нужно запустить целую JVM), это просто катастрофа с точки зрения производительности.

---

### **Вопрос: FastCGI - особенности технологии, преимущества и недостатки относительно CGI.**

#### 1. Что такое FastCGI?

**Формальное определение:** **FastCGI** — это усовершенствованная версия протокола CGI, разработанная для устранения его проблем с производительностью.

**Простыми словами:** FastCGI — это "умный" CGI, который понял, что запускать программу с нуля каждый раз — это ужасно неэффективно. Вместо этого FastCGI говорит: "Давайте запустим программу **один раз**, и пусть она работает постоянно, а веб-сервер будет просто передавать ей запросы по мере их поступления".

#### 2. Особенности технологии и отличия от CGI

Ключевое отличие — модель работы. Вместо "один запрос — один новый процесс" у FastCGI модель **"постоянно работающие процессы"**.

**Принцип работы FastCGI:**
1.  При старте системы **заранее запускается один или несколько процессов** вашего приложения (например, твоего Java-сервера). Эти процессы не привязаны к какому-то конкретному запросу; они просто запущены и ждут работы. Они "слушают" определенный сокет или порт.
2.  Клиент отправляет запрос на сервер.
3.  Веб-сервер Apache, вместо создания нового процесса, **устанавливает соединение с одним из уже работающих** FastCGI-процессов и передает ему данные запроса.
4.  FastCGI-процесс обрабатывает запрос и возвращает ответ веб-серверу.
5.  **Самое главное:** после обработки запроса **процесс не завершается!** Он остается в рабочем состоянии, готовый немедленно принять следующий запрос.

*Именно так и работает твой Java-сервер в этой лабораторной работе.*

#### 3. Преимущества и недостатки

**Преимущества FastCGI перед CGI:**
*   **Огромный прирост производительности:** Это главное преимущество. Нет накладных расходов на создание/уничтожение процессов. Инициализация приложения (запуск JVM, подключение к базе данных) происходит только один раз при старте, а не на каждый запрос.
*   **Эффективность использования ресурсов:** Значительно снижается нагрузка на процессор и память сервера, так как не нужно постоянно "дергать" операционную систему.
*   **Независимость от веб-сервера:** Приложение FastCGI может работать на другом сервере, что позволяет распределять нагрузку.

**Недостатки FastCGI (в сравнении с простотой CGI):**
*   **Более сложная настройка:** Требуется настроить и веб-сервер (чтобы он знал, куда перенаправлять запросы), и само FastCGI-приложение (чтобы оно работало как сервис).
*   **Управление памятью:** Так как процесс живет долго, ошибки в коде, такие как утечки памяти, могут накапливаться со временем и приводить к "падению" или замедлению работы всего приложения, что потребует его перезапуска. В CGI такая ошибка "умирала" бы вместе с процессом после одного запроса.

---

### **Вопрос: FastCGI сервер на языке Java.**

**Определение:** FastCGI сервер на языке Java — это долгоживущее Java-приложение, спроектированное для приема и обработки запросов от веб-сервера по протоколу FastCGI.

**Принцип работы (на примере твоей ЛР):**

1.  **Использование специальной библиотеки:** В проекте используется библиотека (в виде `jar`-файла), которая реализует низкоуровневую часть протокола FastCGI. Она умеет "слушать" сокет и понимать язык, на котором с ней говорит Apache (`mod_proxy_fcgi`).
2.  **Запуск и инициализация:** При запуске `java -jar app.jar` выполняется метод `main`. В нем создается экземпляр FastCGI-интерфейса. Этот момент — **инициализация**, которая происходит **только один раз**.
3.  **Бесконечный цикл ожидания:** Ядром сервера является бесконечный цикл `while (fcgi.FCGIaccept() >= 0)`.
    *   Метод `FCGIaccept()` **блокирует** выполнение программы. Это значит, что Java-процесс "засыпает" и ничего не делает, терпеливо ожидая, пока веб-сервер не пришлет ему новый запрос. Он не тратит ресурсы процессора на пустое ожидание.
4.  **Прием запроса:** Когда Apache перенаправляет запрос, метод `FCGIaccept()` "просыпается" и возвращает управление. Библиотека "распаковывает" данные запроса:
    *   Переменные окружения и заголовки становятся доступны через `System.getProperties()`. *Именно так ты получаешь `CONTENT_LENGTH`.*
    *   Тело POST-запроса направляется в стандартный поток ввода `System.in`. *Именно оттуда ты его и читаешь.*
5.  **Обработка запроса:** Выполняется код внутри `try-catch` блока — твоя бизнес-логика: парсинг, валидация, вычисления.
6.  **Отправка ответа:** Ты формируешь строку-ответ, которая должна имитировать HTTP-ответ (с заголовками `Content-Type` и пустой строкой-разделителем), и выводишь ее в стандартный поток вывода `System.out.print()`. Библиотека перехватывает этот вывод и отправляет его обратно в Apache.
7.  **Возврат в режим ожидания:** После выполнения блока `finally` цикл начинается заново, и сервер снова "засыпает" на методе `FCGIaccept()`, готовый к следующему запросу.

Таким образом, твой Java-сервер — это классический пример эффективного FastCGI-приложения, которое избегает недостатков CGI, постоянно оставаясь в памяти и мгновенно реагируя на новые запросы.